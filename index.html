<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VibeMate: Identity Aware</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
    
    <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* --- RESPONSIVE CORE --- */
        :root { 
            --primary: #8b5cf6;
            --glass: rgba(20, 25, 40, 0.95);
            --success: #10b981;
            --danger: #ef4444;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body { 
            margin: 0; font-family: 'Outfit', sans-serif; 
            overflow: hidden; height: 100dvh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; 
            background: linear-gradient(135deg, #0f0c29, #24243e);
            color: white;
        }

        /* --- AVATAR & CAMERA (RESPONSIVE) --- */
        #core-wrapper { 
            position: relative; 
            /* Responsive Size: 35% of viewport width or max 200px */
            width: min(35vw, 200px); 
            height: min(35vw, 200px); 
            margin: 2vh 0;
            border-radius: 50%; box-shadow: 0 0 40px var(--primary);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            background: #000; z-index: 60;
            border: 3px solid rgba(255,255,255,0.2);
            flex-shrink: 0;
        }
        
        /* Guide Mode: Expanded Rectangle */
        body.guide-active #core-wrapper { 
            width: 90vw; max-width: 400px;
            height: 50vh; max-height: 300px;
            border-radius: 20px; 
            margin-top: 10px;
            box-shadow: 0 0 80px rgba(139, 92, 246, 0.5);
            border-color: #fff;
        }
        
        #video-container {
            position: relative; width: 100%; height: 100%; border-radius: inherit; overflow: hidden; 
        }
        #video-preview, #face-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1);
        }
        
        #core-wrapper.speaking { animation: pulseSpeak 0.6s infinite alternate; border-color: var(--success); }
        @keyframes pulseSpeak { 0% { box-shadow: 0 0 20px var(--success); transform: scale(1); } 100% { box-shadow: 0 0 50px var(--success); transform: scale(1.05); } }

        /* --- UI CONTAINER --- */
        #ui-card {
            width: 100%; max-width: 600px; flex: 1; 
            background: var(--glass); border-radius: 24px 24px 0 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex; flex-direction: column; backdrop-filter: blur(12px);
            box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
            position: relative; overflow: hidden;
        }

        /* --- COMPONENTS --- */
        #voice-dropdown-container {
            position: relative; margin: 10px 15px; z-index: 60;
            transition: opacity 0.3s;
        }
        body.guide-active #voice-dropdown-container { opacity: 0; pointer-events: none; height: 0; margin: 0; }

        #voice-selected {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 12px 16px; 
            display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; font-weight: 600; font-size: 14px;
        }
        #voice-options {
            position: absolute; top: 110%; left: 0; right: 0;
            background: #1a1b2e; border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px; padding: 6px; display: none;
            flex-direction: column; gap: 4px; box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            max-height: 250px; overflow-y: auto;
        }
        #voice-options.show { display: flex; animation: fadeIn 0.2s; }
        .voice-item {
            padding: 10px; border-radius: 8px; cursor: pointer; display: flex; gap: 10px; align-items: center;
            font-size: 14px; color: #ccc; transition: 0.2s;
        }
        .voice-item.active { background: var(--primary); color: white; }

        /* --- CHAT --- */
        #chat-area { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 12px; scroll-behavior: smooth; }
        .msg { max-width: 85%; padding: 12px 16px; border-radius: 18px; font-size: 15px; line-height: 1.4; animation: fadeIn 0.3s forwards; }
        .user { align-self: flex-end; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border-bottom-right-radius: 4px; }
        .ai { align-self: flex-start; background: rgba(255,255,255,0.1); color: #e2e8f0; border-bottom-left-radius: 4px; }

        /* --- INPUT --- */
        #input-area {
            padding: 15px; background: rgba(0,0,0,0.2);
            display: flex; gap: 10px; align-items: center; padding-bottom: max(15px, env(safe-area-inset-bottom));
        }
        #text-input {
            flex: 1; padding: 14px 20px; border-radius: 30px; border: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3); color: white; font-size: 16px; min-width: 0;
        }
        .circle-btn {
            width: 44px; height: 44px; border-radius: 50%; border: none;
            background: rgba(255,255,255,0.1); color: white; cursor: pointer;
            font-size: 18px; flex-shrink: 0; display:flex; align-items:center; justify-content:center;
        }
        .circle-btn.primary { background: var(--primary); }

        /* --- MODALS --- */
        #guide-overlay {
            position: absolute; inset: 0; background: rgba(13, 13, 20, 0.98); z-index: 50;
            display: none; flex-direction: column; padding: 15px; 
            padding-top: 10px; /* Space calculated via JS if needed, but flex handles it */
        }
        #guide-overlay.visible { display: flex; }
        .guide-grid { 
            display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); 
            gap: 12px; overflow-y: auto; padding-bottom: 80px; flex: 1;
        }
        .sign-item {
            background: rgba(255,255,255,0.05); padding: 15px; border-radius: 16px;
            text-align: center; border: 2px solid transparent; transition: 0.2s;
            display: flex; flex-direction: column; align-items: center;
        }
        .sign-item.detected { border-color: var(--success); background: rgba(16, 185, 129, 0.15); transform: scale(1.05); }

        /* --- NEW USER MODAL --- */
        #name-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 200;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            animation: fadeIn 0.5s;
        }
        #name-modal.visible { display: flex; }
        .modal-card {
            background: #1e1e2f; padding: 30px; border-radius: 20px; border: 1px solid var(--primary);
            text-align: center; width: 90%; max-width: 350px;
        }
        #name-input {
            width: 100%; padding: 12px; margin: 15px 0; border-radius: 10px; border: none;
            background: rgba(255,255,255,0.1); color: white; font-size: 16px; text-align: center;
        }
        
        #detection-toast {
            position: fixed; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(16, 185, 129, 0.95); color: white; padding: 8px 20px;
            border-radius: 30px; font-weight: 800; font-size: 14px;
            pointer-events: none; opacity: 0; transition: all 0.3s; z-index: 100;
        }
        #detection-toast.show { opacity: 1; transform: translateX(-50%) translateY(-10px); }
        
        #start-screen {
            position: fixed; inset: 0; z-index: 200; background: #0f0c29;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
        #start-screen.hidden { opacity: 0; pointer-events: none; }
        
        @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size:3rem; margin:0; background:linear-gradient(to right, #a78bfa, #f472b6); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;">VibeMate</h1>
        <p style="color:#94a3b8; margin-bottom:40px;">Identity Aware AI</p>
        <div id="loader" style="color:var(--primary); font-weight:bold; letter-spacing:1px; text-align:center;">LOADING AI MODELS...<br><span style="font-size:12px;opacity:0.7">(This may take a moment)</span></div>
        <button id="btn-begin" onclick="app.start()" style="display:none; margin-top:30px; padding:18px 50px; border-radius:40px; border:none; background:var(--primary); color:white; font-size:18px; font-weight:bold; cursor:pointer; box-shadow:0 0 30px rgba(139, 92, 246, 0.6);">
            ENTER
        </button>
    </div>

    <div id="name-modal">
        <div class="modal-card">
            <h2>Nice to meet you! üëã</h2>
            <p style="color:#ccc;">I don't recognize your face yet. What should I call you?</p>
            <input type="text" id="name-input" placeholder="Your Name">
            <button onclick="app.saveNewUser()" style="background:var(--primary); color:white; border:none; padding:12px 30px; border-radius:20px; font-weight:bold; cursor:pointer;">Save Profile</button>
        </div>
    </div>

    <div id="core-wrapper">
        <div id="video-container">
            <video id="video-preview" autoplay muted playsinline></video>
            <canvas id="face-canvas"></canvas>
        </div>
    </div>

    <div id="detection-toast">üëç DETECTED</div>

    <div id="ui-card">
        
        <div id="guide-overlay">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:10px;">
                <h3 style="margin:0; color:#fff; font-size:16px;">Gesture Library</h3>
                <button onclick="app.toggleGuide()" style="background:rgba(255,255,255,0.1); border:none; color:white; padding:8px 16px; border-radius:20px; font-weight:bold; cursor:pointer;">Close ‚úï</button>
            </div>
            <div class="guide-grid" id="sign-library"></div>
        </div>

        <div id="voice-dropdown-container">
            <div id="voice-selected" onclick="app.toggleVoiceMenu()">
                <span id="voice-label-text">Select Voice...</span>
                <span>‚ñº</span>
            </div>
            <div id="voice-options"></div>
        </div>

        <div id="chat-area">
            <div class="msg ai">üëã Hi! I'm initializing my vision system to see who is there...</div>
        </div>

        <div id="input-area">
            <button class="circle-btn" onclick="app.toggleGuide()">üìñ</button>
            <button class="circle-btn" onclick="app.clearChat()">üóëÔ∏è</button>
            <input type="text" id="text-input" placeholder="Type..." autocomplete="off">
            <button class="circle-btn primary" onclick="app.handleSend()">‚û§</button>
        </div>
    </div>

    <script>
        /**
         * VIBEMATE INTELLIGENT CORE
         * Features: Responsive, Face Recognition, Geometric Detection, Alien Voice
         */
        const Config = {
            voices: [
                { id: 'friend', name: 'Friend', icon: 'üíô', pitch: 1.0, rate: 1.0, lang: 'en-US' },
                { id: 'alien', name: 'Alien', icon: 'üëΩ', pitch: 0.2, rate: 1.1, lang: 'en-US' },
                { id: 'jarvis', name: 'AI Bot', icon: 'ü§ñ', pitch: 0.8, rate: 1.05, lang: 'en-GB' },
                { id: 'chip', name: 'Chip', icon: 'üêøÔ∏è', pitch: 2.0, rate: 1.2, lang: 'en-US' },
                { id: 'narrator', name: 'Narrator', icon: 'üéôÔ∏è', pitch: 0.5, rate: 0.85, lang: 'en-US' }
            ],
            signs: [
                { id: 'HELLO', emoji: '‚úã', title: 'Hello', desc: 'Open Palm' },
                { id: 'YES', emoji: 'üëç', title: 'Yes', desc: 'Thumbs Up' },
                { id: 'NO', emoji: '‚úä', title: 'No', desc: 'Closed Fist' },
                { id: 'OK', emoji: 'üëå', title: 'Okay', desc: 'Index touches Thumb' },
                { id: 'LOVE', emoji: 'ü§ü', title: 'Love', desc: 'Thumb+Index+Pinky' },
                { id: 'PEACE', emoji: '‚úåÔ∏è', title: 'Peace', desc: 'Index + Middle Up' },
                { id: 'POINT', emoji: '‚òùÔ∏è', title: 'Point', desc: 'Index Up Only' },
                { id: 'STOP', emoji: 'üõë', title: 'Stop', desc: 'Fingers Spread Wide' },
                { id: 'QUIET', emoji: 'ü§´', title: 'Quiet', desc: 'Index on Lips' },
                { id: 'THINK', emoji: 'ü§î', title: 'Think', desc: 'Index on Temple' },
                { id: 'LISTEN', emoji: 'üëÇ', title: 'Listen', desc: 'Hand near Ear' },
                { id: 'HEART', emoji: 'ü´∂', title: 'Heart', desc: 'Two hands shape' },
                { id: 'MYSELF', emoji: 'üôã', title: 'Me', desc: 'Thumb to Chest' }
            ]
        };

        class VibeMateApp {
            constructor() {
                this.state = {
                    voiceIdx: 0,
                    guideOpen: false,
                    currentUser: null,
                    faceMatcher: null,
                    pendingDescriptor: null, // For saving new users
                    lastCheckTime: 0,
                    knownFaces: [], // Loaded from localstorage
                    lastSign: null,
                    holdCounter: 0,
                    emotion: 'neutral'
                };
                
                this.els = {
                    video: document.getElementById('video-preview'),
                    canvas: document.getElementById('face-canvas'),
                    ctx: document.getElementById('face-canvas').getContext('2d'),
                    wrapper: document.getElementById('core-wrapper'),
                    chat: document.getElementById('chat-area'),
                    input: document.getElementById('text-input'),
                    toast: document.getElementById('detection-toast'),
                    voiceLabel: document.getElementById('voice-label-text'),
                    voiceOpts: document.getElementById('voice-options'),
                    nameModal: document.getElementById('name-modal'),
                    nameInput: document.getElementById('name-input')
                };
            }

            async init() {
                try {
                    // Load Known Faces
                    const stored = localStorage.getItem('vibemate_users');
                    if(stored) {
                        const parsed = JSON.parse(stored);
                        this.state.knownFaces = parsed.map(u => new faceapi.LabeledFaceDescriptors(u.label, [new Float32Array(u.descriptor)]));
                        if(this.state.knownFaces.length > 0) {
                            this.state.faceMatcher = new faceapi.FaceMatcher(this.state.knownFaces, 0.6);
                        }
                    }

                    // Load Models (Heavier load for recognition)
                    await Promise.all([
                        faceapi.nets.tinyFaceDetector.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models'),
                        faceapi.nets.faceLandmark68Net.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models'),
                        faceapi.nets.faceRecognitionNet.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models'),
                        faceapi.nets.faceExpressionNet.loadFromUri('https://justadudewhohacks.github.io/face-api.js/models')
                    ]);
                    
                    document.getElementById('loader').innerText = "SYSTEM READY";
                    document.getElementById('btn-begin').style.display = "block";
                    this.setupUI();
                } catch(e) { console.error(e); alert("Network Error: Could not load AI models."); }
            }

            setupUI() {
                // Signs
                const lib = document.getElementById('sign-library');
                Config.signs.forEach(s => {
                    const el = document.createElement('div');
                    el.className = 'sign-item'; el.id = `sign-${s.id}`;
                    el.innerHTML = `<span style="font-size:28px; margin-bottom:5px;">${s.emoji}</span><div style="font-size:13px;font-weight:bold;color:var(--primary);">${s.title}</div><div style="font-size:11px;color:#aaa">${s.desc}</div>`;
                    lib.appendChild(el);
                });

                // Voices
                this.els.voiceOpts.innerHTML = '';
                Config.voices.forEach((v, i) => {
                    const item = document.createElement('div');
                    item.className = `voice-item ${i===0?'active':''}`;
                    item.innerHTML = `<span>${v.icon}</span><span>${v.name}</span>`;
                    item.onclick = () => {
                        this.state.voiceIdx = i;
                        this.updateVoiceUI();
                        this.speak("Voice activated.", true);
                        this.els.voiceOpts.classList.remove('show');
                    };
                    this.els.voiceOpts.appendChild(item);
                });
                this.updateVoiceUI();

                this.els.input.addEventListener('keypress', e => { if(e.key==='Enter') this.handleSend(); });
                
                document.addEventListener('click', (e) => {
                    const container = document.getElementById('voice-dropdown-container');
                    if(!container.contains(e.target)) this.els.voiceOpts.classList.remove('show');
                });
            }

            updateVoiceUI() {
                const v = Config.voices[this.state.voiceIdx];
                this.els.voiceLabel.innerText = `${v.icon} ${v.name}`;
            }
            toggleVoiceMenu() { this.els.voiceOpts.classList.toggle('show'); }

            async start() {
                document.getElementById('start-screen').classList.add('hidden');
                
                // Camera constraints for responsiveness
                const constraints = { video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                this.els.video.srcObject = stream;
                
                this.els.video.onloadedmetadata = () => {
                    this.els.video.play();
                    this.resizeCanvas();
                    window.addEventListener('resize', () => this.resizeCanvas());

                    this.hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                    this.hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6});
                    this.hands.onResults(this.onResults.bind(this));
                    
                    this.loop();
                };
            }

            resizeCanvas() {
                this.els.canvas.width = this.els.video.videoWidth;
                this.els.canvas.height = this.els.video.videoHeight;
            }

            // --- MAIN LOOP ---
            async loop() {
                const now = Date.now();
                await this.hands.send({image: this.els.video});
                
                // Run Face Detection (Expression + Recognition)
                // We use TinyFaceDetector for speed
                const detections = await faceapi.detectSingleFace(this.els.video, new faceapi.TinyFaceDetectorOptions())
                    .withFaceLandmarks().withFaceExpressions().withFaceDescriptor();

                if(detections) {
                    this.state.emotion = Object.keys(detections.expressions).reduce((a, b) => detections.expressions[a] > detections.expressions[b] ? a : b);
                    this.drawFaceBox(detections.detection.box);
                    
                    // RECOGNITION LOGIC (Throttled to every 2 seconds to save battery)
                    if (!this.state.currentUser && now - this.state.lastCheckTime > 2000 && !this.els.nameModal.classList.contains('visible')) {
                        this.state.lastCheckTime = now;
                        this.handleRecognition(detections);
                    }
                } else {
                    this.state.faceBox = null;
                }

                requestAnimationFrame(this.loop.bind(this));
            }

            handleRecognition(detection) {
                if (!this.state.faceMatcher) {
                    // No users saved yet -> Prompt new user
                    this.promptNewUser(detection.descriptor);
                    return;
                }

                const match = this.state.faceMatcher.findBestMatch(detection.descriptor);
                if (match.label === 'unknown') {
                    // Unknown face -> Prompt
                    this.promptNewUser(detection.descriptor);
                } else {
                    // Known User
                    this.state.currentUser = match.label;
                    const greeting = `Welcome back, ${this.state.currentUser}!`;
                    this.addMsg(greeting, 'ai');
                    this.speak(greeting);
                }
            }

            promptNewUser(descriptor) {
                this.state.pendingDescriptor = descriptor;
                this.els.nameModal.classList.add('visible');
                this.speak("I don't know you yet. What is your name?");
            }

            saveNewUser() {
                const name = this.els.nameInput.value.trim();
                if(!name) return;

                // Save to state
                const user = new faceapi.LabeledFaceDescriptors(name, [this.state.pendingDescriptor]);
                
                // Update Matcher
                if(this.state.faceMatcher) {
                    this.state.knownFaces.push(user);
                    this.state.faceMatcher = new faceapi.FaceMatcher(this.state.knownFaces, 0.6);
                } else {
                    this.state.knownFaces = [user];
                    this.state.faceMatcher = new faceapi.FaceMatcher(this.state.knownFaces, 0.6);
                }

                // Save to LocalStorage (Convert Float32Array to standard array for JSON)
                const storageData = this.state.knownFaces.map(lf => ({
                    label: lf.label,
                    descriptor: Array.from(lf.descriptors[0])
                }));
                localStorage.setItem('vibemate_users', JSON.stringify(storageData));

                this.els.nameModal.classList.remove('visible');
                this.state.currentUser = name;
                this.state.pendingDescriptor = null;
                
                const msg = `Nice to meet you, ${name}! I'll remember you now.`;
                this.addMsg(msg, 'ai');
                this.speak(msg);
            }

            drawFaceBox(box) {
                // Must resize box to canvas dimensions if video is scaled via CSS (handled by internal canvas size usually matching video source, but visual scaling needs care)
                // For this implementation, canvas matches source resolution, CSS scales visual.
                const ctx = this.els.ctx;
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.strokeRect(box.x, box.y, box.width, box.height);
                this.state.faceBox = box; // Store for gesture context
            }

            onResults(results) {
                // Clear previous drawings (Keep Face Box logic separate or clear all)
                // We clear all here, face box is drawn in loop() loop.
                // To sync: draw face box here too or accept flicker. Better: Clear here.
                this.els.ctx.clearRect(0, 0, this.els.canvas.width, this.els.canvas.height);
                
                // Redraw Face Box if exists (from state)
                if(this.state.faceBox) {
                    const b = this.state.faceBox;
                    this.els.ctx.strokeStyle = '#3b82f6'; this.els.ctx.lineWidth = 3;
                    this.els.ctx.strokeRect(b.x, b.y, b.width, b.height);
                }

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(this.els.ctx, landmarks, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2}); 
                        drawLandmarks(this.els.ctx, landmarks, {color: '#ff0000', lineWidth: 1, radius: 3});
                    }

                    const sign = this.detectGeometricSign(results.multiHandLandmarks[0]);
                    if(sign) this.processDetection(sign);
                    else { this.state.lastSign = null; this.state.holdCounter = 0; }
                }
            }

            detectGeometricSign(lm) {
                const isFingerUp = (tip, pip) => lm[tip].y < lm[pip].y;
                const dist = (p1, p2) => Math.hypot(lm[p1].x - lm[p2].x, lm[p1].y - lm[p2].y);
                
                const thumbOpen = dist(4, 17) > 0.15;
                const indexUp = isFingerUp(8, 6);
                const middleUp = isFingerUp(12, 10);
                const ringUp = isFingerUp(16, 14);
                const pinkyUp = isFingerUp(20, 18);
                const allFingersUp = indexUp && middleUp && ringUp && pinkyUp;

                let id = null;
                // Basic Logic
                if (!thumbOpen && !indexUp && !middleUp && !ringUp && !pinkyUp) id = "NO";
                else if (thumbOpen && !indexUp && !middleUp && !ringUp && !pinkyUp) id = "YES";
                else if (thumbOpen && allFingersUp) id = "HELLO";
                else if (!thumbOpen && indexUp && middleUp && !ringUp && !pinkyUp) id = "PEACE";
                else if (!thumbOpen && indexUp && !middleUp && !ringUp && !pinkyUp) id = "POINT";
                else if (thumbOpen && !indexUp && !middleUp && !ringUp && pinkyUp) id = "CALL";
                
                // Contextual
                if (this.state.faceBox) {
                    const hx = lm[9].x * this.els.canvas.width; 
                    const hy = lm[9].y * this.els.canvas.height; 
                    const f = this.state.faceBox;
                    
                    const nearMouth = hy > f.y + f.height * 0.6 && hy < f.y + f.height * 1.3;
                    const nearEar = (hx < f.x || hx > f.x + f.width) && (hy > f.y && hy < f.y + f.height);
                    const nearTemple = hy < f.y + f.height * 0.4;

                    if (id === "POINT" && nearMouth) id = "QUIET";
                    if (id === "POINT" && nearTemple) id = "THINK";
                    if (id === "HELLO" && nearEar) id = "LISTEN";
                    if (allFingersUp && nearTemple) id = "HEART"; // Simplified
                    if (id === "YES" && nearMouth) id = "MYSELF"; // Simplified
                }
                return id;
            }

            processDetection(id) {
                if(this.state.guideOpen) {
                    document.querySelectorAll('.sign-item').forEach(e => e.classList.remove('detected'));
                    document.getElementById(`sign-${id}`)?.classList.add('detected');
                }

                if (id === this.state.lastSign) {
                    this.state.holdCounter++;
                    if (this.state.holdCounter === 20) {
                        this.triggerAction(id);
                        this.state.holdCounter = -30;
                    }
                } else {
                    this.state.lastSign = id;
                    this.state.holdCounter = 0;
                }
            }

            triggerAction(id) {
                const sign = Config.signs.find(s => s.id === id);
                if (!sign) return;
                this.els.toast.innerText = `${sign.emoji} DETECTED: ${sign.title}`;
                this.els.toast.classList.add('show');
                setTimeout(() => this.els.toast.classList.remove('show'), 2000);
                this.addMsg(sign.title, 'user');
                this.fetchAI(sign.title);
            }

            async handleSend() {
                const text = this.els.input.value.trim();
                if (!text) return;
                this.els.input.value = '';
                this.addMsg(text, 'user');
                this.fetchAI(text);
            }

            async fetchAI(text) {
                const tempId = this.addMsg("Thinking...", 'ai', true);
                try {
                    const res = await fetch('/.netlify/functions/chat', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message: text, history: [], emotion: this.state.emotion })
                    });
                    if (!res.ok) throw new Error();
                    const data = await res.json();
                    document.getElementById(tempId).remove();
                    this.addMsg(data.reply, 'ai');
                    this.speak(data.reply);
                } catch (e) {
                    document.getElementById(tempId).innerText = "Thinking error...";
                }
            }

            addMsg(text, role, isTemp=false) {
                const div = document.createElement('div');
                div.className = `msg ${role}`; div.innerText = text;
                if(isTemp) div.id = `temp-${Date.now()}`;
                this.els.chat.appendChild(div);
                this.els.chat.scrollTop = this.els.chat.scrollHeight;
                return div.id;
            }

            speak(text, force=false) {
                window.speechSynthesis.cancel();
                const ut = new SpeechSynthesisUtterance(text);
                const v = Config.voices[this.state.voiceIdx];
                ut.pitch = v.pitch; ut.rate = v.rate;
                const sysVoices = window.speechSynthesis.getVoices();
                const preferred = sysVoices.find(sv => sv.lang === v.lang && sv.name.toLowerCase().includes(v.id === 'jarvis' ? 'male' : 'female'));
                if(preferred) ut.voice = preferred;
                ut.onstart = () => this.els.wrapper.classList.add('speaking');
                ut.onend = () => this.els.wrapper.classList.remove('speaking');
                window.speechSynthesis.speak(ut);
            }

            toggleGuide() {
                this.state.guideOpen = !this.state.guideOpen;
                document.getElementById('guide-overlay').classList.toggle('visible');
                document.body.classList.toggle('guide-active');
            }
            clearChat() { this.els.chat.innerHTML = ''; }
        }

        const app = new VibeMateApp();
        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
